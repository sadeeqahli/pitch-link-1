import { PassThrough } from 'node:stream';
import { options, h, Fragment } from 'preact';

const UNSAFE_NAME = /[\s\n\\/='"\0<>]/;
const NAMESPACE_REPLACE_REGEX = /^(xlink|xmlns|xml)([A-Z])/;
const HTML_LOWER_CASE = /^accessK|^auto[A-Z]|^cell|^ch|^col|cont|cross|dateT|encT|form[A-Z]|frame|hrefL|inputM|maxL|minL|noV|playsI|popoverT|readO|rowS|src[A-Z]|tabI|useM|item[A-Z]/;
const SVG_CAMEL_CASE = /^ac|^ali|arabic|basel|cap|clipPath$|clipRule$|color|dominant|enable|fill|flood|font|glyph[^R]|horiz|image|letter|lighting|marker[^WUH]|overline|panose|pointe|paint|rendering|shape|stop|strikethrough|stroke|text[^L]|transform|underline|unicode|units|^v[^i]|^w|^xH/; // Boolean DOM properties that translate to enumerated ('true'/'false') attributes

const HTML_ENUMERATED = new Set(['draggable', 'spellcheck']); // DOM properties that should NOT have "px" added when numeric

const ENCODED_ENTITIES = /["&<]/;
/** @param {string} str */

function encodeEntities(str) {
  // Skip all work for strings with no entities needing encoding:
  if (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;
  let last = 0,
      i = 0,
      out = '',
      ch = ''; // Seek forward in str until the next entity char:

  for (; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 34:
        ch = '&quot;';
        break;

      case 38:
        ch = '&amp;';
        break;

      case 60:
        ch = '&lt;';
        break;

      default:
        continue;
    } // Append skipped/buffered characters and the encoded entity:


    if (i !== last) out = out + str.slice(last, i);
    out = out + ch; // Start the next seek/buffer after the entity's offset:

    last = i + 1;
  }

  if (i !== last) out = out + str.slice(last, i);
  return out;
}
const JS_TO_CSS = {};
const IS_NON_DIMENSIONAL = new Set(['animation-iteration-count', 'border-image-outset', 'border-image-slice', 'border-image-width', 'box-flex', 'box-flex-group', 'box-ordinal-group', 'column-count', 'fill-opacity', 'flex', 'flex-grow', 'flex-negative', 'flex-order', 'flex-positive', 'flex-shrink', 'flood-opacity', 'font-weight', 'grid-column', 'grid-row', 'line-clamp', 'line-height', 'opacity', 'order', 'orphans', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'tab-size', 'widows', 'z-index', 'zoom']);
const CSS_REGEX = /[A-Z]/g; // Convert an Object style to a CSSText string

function styleObjToCss(s) {
  let str = '';

  for (let prop in s) {
    let val = s[prop];

    if (val != null && val !== '') {
      const name = prop[0] == '-' ? prop : JS_TO_CSS[prop] || (JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());
      let suffix = ';';

      if (typeof val === 'number' && // Exclude custom-attributes
      !name.startsWith('--') && !IS_NON_DIMENSIONAL.has(name)) {
        suffix = 'px;';
      }

      str = str + name + ':' + val + suffix;
    }
  }

  return str || undefined;
}

function markAsDirty() {
  this.__d = true;
}

function createComponent(vnode, context) {
  return {
    __v: vnode,
    context,
    props: vnode.props,
    // silently drop state updates
    setState: markAsDirty,
    forceUpdate: markAsDirty,
    __d: true,
    // hooks
    __h: new Array(0)
  };
} // Necessary for createContext api. Setting this property will pass
/**
 * @template T
 */

class Deferred {
  constructor() {
    // eslint-disable-next-line lines-around-comment

    /** @type {Promise<T>} */
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }

}

// Options hooks
const DIFF = '__b';
const RENDER = '__r';
const DIFFED = 'diffed';
const COMMIT = '__c';
const SKIP_EFFECTS = '__s';
const CATCH_ERROR = '__e'; // VNode properties

const COMPONENT = '__c';
const CHILDREN = '__k';
const PARENT = '__';

const VNODE = '__v';
const DIRTY = '__d';
const NEXT_STATE = '__s';
const CHILD_DID_SUSPEND = '__c';

const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const isArray = Array.isArray;
const assign = Object.assign;
const EMPTY_STR = ''; // Global state for the current render pass

let beforeDiff, afterDiff, renderHook, ummountHook;
/**
 * Render Preact JSX + Components to an HTML string.
 * @param {VNode} vnode	JSX Element / VNode to render
 * @param {Object} [context={}] Initial root context object
 * @param {RendererState} [_rendererState] for internal use
 * @returns {string} serialized HTML
 */

function renderToString(vnode, context, _rendererState) {
  // Performance optimization: `renderToString` is synchronous and we
  // therefore don't execute any effects. To do that we pass an empty
  // array to `options._commit` (`__c`). But we can go one step further
  // and avoid a lot of dirty checks and allocations by setting
  // `options._skipEffects` (`__s`) too.
  const previousSkipEffects = options[SKIP_EFFECTS];
  options[SKIP_EFFECTS] = true; // store options hooks once before each synchronous render call

  beforeDiff = options[DIFF];
  afterDiff = options[DIFFED];
  renderHook = options[RENDER];
  ummountHook = options.unmount;
  const parent = h(Fragment, null);
  parent[CHILDREN] = [vnode];

  try {
    const rendered = _renderToString(vnode, context || EMPTY_OBJ, false, undefined, parent, false, _rendererState);

    if (isArray(rendered)) {
      return rendered.join(EMPTY_STR);
    }

    return rendered;
  } catch (e) {
    if (e.then) {
      throw new Error('Use "renderToStringAsync" for suspenseful rendering.');
    }

    throw e;
  } finally {
    // options._commit, we don't schedule any effects in this library right now,
    // so we can pass an empty queue to this hook.
    if (options[COMMIT]) options[COMMIT](vnode, EMPTY_ARR);
    options[SKIP_EFFECTS] = previousSkipEffects;
    EMPTY_ARR.length = 0;
  }
}
/**
 * @param {VNode} vnode
 * @param {Record<string, unknown>} context
 */

function renderClassComponent(vnode, context) {
  let type =
  /** @type {import("preact").ComponentClass<typeof vnode.props>} */
  vnode.type;
  let isMounting = true;
  let c;

  if (vnode[COMPONENT]) {
    isMounting = false;
    c = vnode[COMPONENT];
    c.state = c[NEXT_STATE];
  } else {
    c = new type(vnode.props, context);
  }

  vnode[COMPONENT] = c;
  c[VNODE] = vnode;
  c.props = vnode.props;
  c.context = context; // turn off stateful re-rendering:

  c[DIRTY] = true;
  if (c.state == null) c.state = EMPTY_OBJ;

  if (c[NEXT_STATE] == null) {
    c[NEXT_STATE] = c.state;
  }

  if (type.getDerivedStateFromProps) {
    c.state = assign({}, c.state, type.getDerivedStateFromProps(c.props, c.state));
  } else if (isMounting && c.componentWillMount) {
    c.componentWillMount(); // If the user called setState in cWM we need to flush pending,
    // state updates. This is the same behaviour in React.

    c.state = c[NEXT_STATE] !== c.state ? c[NEXT_STATE] : c.state;
  } else if (!isMounting && c.componentWillUpdate) {
    c.componentWillUpdate();
  }

  if (renderHook) renderHook(vnode);
  return c.render(c.props, c.state, context);
}
/**
 * Recursively render VNodes to HTML.
 * @param {VNode|any} vnode
 * @param {any} context
 * @param {boolean} isSvgMode
 * @param {any} selectValue
 * @param {VNode} parent
 * @param {boolean} asyncMode
 * @param {RendererState | undefined} [renderer]
 * @returns {string | Promise<string> | (string | Promise<string>)[]}
 */


function _renderToString(vnode, context, isSvgMode, selectValue, parent, asyncMode, renderer) {
  // Ignore non-rendered VNodes/values
  if (vnode == null || vnode === true || vnode === false || vnode === EMPTY_STR) {
    return EMPTY_STR;
  }

  let vnodeType = typeof vnode; // Text VNodes: escape as HTML

  if (vnodeType != 'object') {
    if (vnodeType == 'function') return EMPTY_STR;
    return vnodeType == 'string' ? encodeEntities(vnode) : vnode + EMPTY_STR;
  } // Recurse into children / Arrays


  if (isArray(vnode)) {
    let rendered = EMPTY_STR,
        renderArray;
    parent[CHILDREN] = vnode;

    for (let i = 0; i < vnode.length; i++) {
      let child = vnode[i];
      if (child == null || typeof child == 'boolean') continue;

      const childRender = _renderToString(child, context, isSvgMode, selectValue, parent, asyncMode, renderer);

      if (typeof childRender == 'string') {
        rendered = rendered + childRender;
      } else {
        if (!renderArray) {
          renderArray = [];
        }

        if (rendered) renderArray.push(rendered);
        rendered = EMPTY_STR;

        if (isArray(childRender)) {
          renderArray.push(...childRender);
        } else {
          renderArray.push(childRender);
        }
      }
    }

    if (renderArray) {
      if (rendered) renderArray.push(rendered);
      return renderArray;
    }

    return rendered;
  } // VNodes have {constructor:undefined} to prevent JSON injection:


  if (vnode.constructor !== undefined) return EMPTY_STR;
  vnode[PARENT] = parent;
  if (beforeDiff) beforeDiff(vnode);
  let type = vnode.type,
      props = vnode.props; // Invoke rendering on Components

  if (typeof type == 'function') {
    let cctx = context,
        contextType,
        rendered,
        component;

    if (type === Fragment) {
      // Serialized precompiled JSX.
      if ('tpl' in props) {
        let out = EMPTY_STR;

        for (let i = 0; i < props.tpl.length; i++) {
          out = out + props.tpl[i];

          if (props.exprs && i < props.exprs.length) {
            const value = props.exprs[i];
            if (value == null) continue; // Check if we're dealing with a vnode or an array of nodes

            if (typeof value == 'object' && (value.constructor === undefined || isArray(value))) {
              out = out + _renderToString(value, context, isSvgMode, selectValue, vnode, asyncMode, renderer);
            } else {
              // Values are pre-escaped by the JSX transform
              out = out + value;
            }
          }
        }

        return out;
      } else if ('UNSTABLE_comment' in props) {
        // Fragments are the least used components of core that's why
        // branching here for comments has the least effect on perf.
        return '<!--' + encodeEntities(props.UNSTABLE_comment) + '-->';
      }

      rendered = props.children;
    } else {
      contextType = type.contextType;

      if (contextType != null) {
        let provider = context[contextType.__c];
        cctx = provider ? provider.props.value : contextType.__;
      }

      let isClassComponent = type.prototype && typeof type.prototype.render == 'function';

      if (isClassComponent) {
        rendered =
        /**#__NOINLINE__**/
        renderClassComponent(vnode, cctx);
        component = vnode[COMPONENT];
      } else {
        vnode[COMPONENT] = component =
        /**#__NOINLINE__**/
        createComponent(vnode, cctx); // If a hook invokes setState() to invalidate the component during rendering,
        // re-render it up to 25 times to allow "settling" of memoized states.
        // Note:
        //   This will need to be updated for Preact 11 to use internal.flags rather than component._dirty:
        //   https://github.com/preactjs/preact/blob/d4ca6fdb19bc715e49fd144e69f7296b2f4daa40/src/diff/component.js#L35-L44

        let count = 0;

        while (component[DIRTY] && count++ < 25) {
          component[DIRTY] = false;
          if (renderHook) renderHook(vnode);
          rendered = type.call(component, props, cctx);
        }

        component[DIRTY] = true;
      }

      if (component.getChildContext != null) {
        context = assign({}, context, component.getChildContext());
      }

      if (isClassComponent && options.errorBoundaries && (type.getDerivedStateFromError || component.componentDidCatch)) {
        // When a component returns a Fragment node we flatten it in core, so we
        // need to mirror that logic here too
        let isTopLevelFragment = rendered != null && rendered.type === Fragment && rendered.key == null && rendered.props.tpl == null;
        rendered = isTopLevelFragment ? rendered.props.children : rendered;

        try {
          return _renderToString(rendered, context, isSvgMode, selectValue, vnode, asyncMode, renderer);
        } catch (err) {
          if (type.getDerivedStateFromError) {
            component[NEXT_STATE] = type.getDerivedStateFromError(err);
          }

          if (component.componentDidCatch) {
            component.componentDidCatch(err, EMPTY_OBJ);
          }

          if (component[DIRTY]) {
            rendered = renderClassComponent(vnode, context);
            component = vnode[COMPONENT];

            if (component.getChildContext != null) {
              context = assign({}, context, component.getChildContext());
            }

            let isTopLevelFragment = rendered != null && rendered.type === Fragment && rendered.key == null && rendered.props.tpl == null;
            rendered = isTopLevelFragment ? rendered.props.children : rendered;
            return _renderToString(rendered, context, isSvgMode, selectValue, vnode, asyncMode, renderer);
          }

          return EMPTY_STR;
        } finally {
          if (afterDiff) afterDiff(vnode);
          vnode[PARENT] = null;
          if (ummountHook) ummountHook(vnode);
        }
      }
    } // When a component returns a Fragment node we flatten it in core, so we
    // need to mirror that logic here too


    let isTopLevelFragment = rendered != null && rendered.type === Fragment && rendered.key == null && rendered.props.tpl == null;
    rendered = isTopLevelFragment ? rendered.props.children : rendered;

    try {
      // Recurse into children before invoking the after-diff hook
      const str = _renderToString(rendered, context, isSvgMode, selectValue, vnode, asyncMode, 